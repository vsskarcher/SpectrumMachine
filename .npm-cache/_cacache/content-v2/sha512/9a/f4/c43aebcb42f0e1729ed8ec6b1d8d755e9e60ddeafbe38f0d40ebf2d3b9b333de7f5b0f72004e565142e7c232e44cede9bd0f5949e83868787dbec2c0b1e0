{"_id":"ts-brand","_rev":"4-47a8aa839151c31c181ee6d11ff2339c","name":"ts-brand","dist-tags":{"latest":"0.2.0"},"versions":{"0.0.1":{"name":"ts-brand","version":"0.0.1","keywords":["typescript","opaque","branding","type"],"author":{"name":"Wil Lee","email":"kourge@gmail.com"},"license":"MIT","_id":"ts-brand@0.0.1","maintainers":[{"name":"kourge","email":"kourge@gmail.com"}],"homepage":"https://github.com/kourge/ts-brand#readme","bugs":{"url":"https://github.com/kourge/ts-brand/issues"},"dist":{"shasum":"c373a8b68e5aab1109f4dc84399a6877fbfa0cee","tarball":"https://registry.npmjs.org/ts-brand/-/ts-brand-0.0.1.tgz","integrity":"sha512-4ZmnJP33afeQ3WMb8eOqkIcMk71/vOuc+Ijn6BUCQ1U8Q/8zlghe68eOxEOD3IsUb4tAMkG/bU5dF2DVvnge7A==","signatures":[{"sig":"MEUCIF4n4mqbTINKgkOeBUu/35+ahmSBrAUnbIgfCl1CZPWwAiEAh7IBezv/A1k558TkeXHuXOMifSsM9RbaXdNWf/Kbssw=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"jest":{"testRegex":"(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$","transform":{"^.+\\.tsx?$":"<rootDir>/node_modules/ts-jest/preprocessor.js"},"moduleFileExtensions":["ts","tsx","js","jsx","json"]},"main":"lib/index.js","gitHead":"af731301b160df75b78865fdd7e3d7526209b4dc","scripts":{"test":"jest","build":"tsc"},"_npmUser":{"name":"kourge","email":"kourge@gmail.com"},"repository":{"url":"git+https://github.com/kourge/ts-brand.git","type":"git"},"_npmVersion":"5.4.2","description":"Reusable type branding in TypeScript","directories":{},"_nodeVersion":"8.3.0","devDependencies":{"jest":"^21.2.1","ts-jest":"^21.0.1","typescript":"^2.5.3","@types/jest":"^21.1.1"},"_npmOperationalInternal":{"tmp":"tmp/ts-brand-0.0.1.tgz_1506983408828_0.6684220773167908","host":"s3://npm-registry-packages"}},"0.0.2":{"name":"ts-brand","version":"0.0.2","keywords":["typescript","opaque","branding","type"],"author":{"name":"Wil Lee","email":"kourge@gmail.com"},"license":"MIT","_id":"ts-brand@0.0.2","maintainers":[{"name":"kourge","email":"kourge@gmail.com"}],"homepage":"https://github.com/kourge/ts-brand#readme","bugs":{"url":"https://github.com/kourge/ts-brand/issues"},"dist":{"shasum":"b6cbca6ac94df1050a05844e23944eaeda1738a0","tarball":"https://registry.npmjs.org/ts-brand/-/ts-brand-0.0.2.tgz","integrity":"sha512-UhSzWY4On9ZHIj6DKkRYVN/8OaprbLAZ3b/Y2AJwdl6oozSABsQ0PvwDh4vOVdkvOtWQOkIrjctZ1kj8YfF3jA==","signatures":[{"sig":"MEUCIQC/8kOh+qB8slbZZKBY89oJyT/reBOs5PT/pR1p4xXfZgIgW3McjTVrFFS9H235f7R1thnbDCnJZ1O6ac66zuDbr9Q=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"jest":{"testRegex":"(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$","transform":{"^.+\\.tsx?$":"<rootDir>/node_modules/ts-jest/preprocessor.js"},"moduleFileExtensions":["ts","tsx","js","jsx","json"]},"main":"lib/index.js","gitHead":"0184f81fa0d6e0ed07204060a38a3dd6f9a8efc7","scripts":{"test":"jest","build":"tsc"},"typings":"lib/index.d.ts","_npmUser":{"name":"kourge","email":"kourge@gmail.com"},"repository":{"url":"git+https://github.com/kourge/ts-brand.git","type":"git"},"_npmVersion":"5.5.1","description":"Reusable type branding in TypeScript","directories":{},"_nodeVersion":"8.3.0","devDependencies":{"jest":"^21.2.1","ts-jest":"^21.0.1","typescript":"^2.5.3","@types/jest":"^21.1.1"},"_npmOperationalInternal":{"tmp":"tmp/ts-brand-0.0.2.tgz_1509233577895_0.33010188373737037","host":"s3://npm-registry-packages"}},"0.1.0":{"name":"ts-brand","version":"0.1.0","keywords":["typescript","opaque","branding","type"],"author":{"name":"Wil Lee","email":"kourge@gmail.com"},"license":"MIT","_id":"ts-brand@0.1.0","maintainers":[{"name":"kourge","email":"kourge@gmail.com"}],"homepage":"https://github.com/kourge/ts-brand#readme","bugs":{"url":"https://github.com/kourge/ts-brand/issues"},"dist":{"shasum":"9fd2af7566e09debda2a3631b027101a965762dc","tarball":"https://registry.npmjs.org/ts-brand/-/ts-brand-0.1.0.tgz","fileCount":8,"integrity":"sha512-DDPY7vBCCAMC9nN4STBSF3s4+aay/jZFTVmISngAoTsYRG/drdzAXPr8npKah0AhwjHspys3/+DyR2QwyZ3JgA==","signatures":[{"sig":"MEUCIA6pZNPLtQ23SELJ9M3bPBhOhcuLk9flI0c8JIG1HQtsAiEAqwnF7KBn0higPkptwPsGq3ohWnTtfRZfvtF2zsPuu7I=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":13626},"jest":{"testRegex":"(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$","transform":{"^.+\\.tsx?$":"ts-jest"},"moduleFileExtensions":["ts","tsx","js","jsx","json"]},"main":"lib/index.js","gitHead":"cccf72c67abd10a73d399d5c26e3fdd46eda6a74","scripts":{"test":"jest","build":"tsc"},"typings":"lib/index.d.ts","_npmUser":{"name":"kourge","email":"kourge@gmail.com"},"repository":{"url":"git+https://github.com/kourge/ts-brand.git","type":"git"},"_npmVersion":"8.19.3","description":"Reusable type branding in TypeScript","directories":{},"_nodeVersion":"16.19.1","_hasShrinkwrap":false,"devDependencies":{"jest":"^26.6.3","ts-jest":"^26.5.6","typescript":"^4.9.5","@types/jest":"^26.0.24"},"_npmOperationalInternal":{"tmp":"tmp/ts-brand_0.1.0_1710551152116_0.5405244975329759","host":"s3://npm-registry-packages"}},"0.2.0":{"name":"ts-brand","version":"0.2.0","description":"Reusable type branding in TypeScript","main":"lib/index.js","typings":"lib/index.d.ts","scripts":{"test":"jest","build":"tsc"},"repository":{"type":"git","url":"git+https://github.com/kourge/ts-brand.git"},"keywords":["typescript","opaque","branding","type"],"author":{"name":"Wil Lee","email":"kourge@gmail.com"},"license":"MIT","bugs":{"url":"https://github.com/kourge/ts-brand/issues"},"homepage":"https://github.com/kourge/ts-brand#readme","devDependencies":{"@types/jest":"^26.0.24","jest":"^26.6.3","ts-jest":"^26.5.6","typescript":"^4.9.5"},"jest":{"transform":{"^.+\\.tsx?$":"ts-jest"},"testRegex":"(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$","moduleFileExtensions":["ts","tsx","js","jsx","json"]},"_id":"ts-brand@0.2.0","gitHead":"e0c6c073414a1e5ff1d6abbe4e2bc1af587c8fa2","_nodeVersion":"20.14.0","_npmVersion":"10.7.0","dist":{"integrity":"sha512-H5uo7OqMvd91D2EefFmltBP9oeNInNzWLAZUSt6coGDn8b814Eis6SnEtzyXORr9ccEb38PfzyiRVDacdkycSQ==","shasum":"920aae2341e53d683e198e79ef8cf98086608d22","tarball":"https://registry.npmjs.org/ts-brand/-/ts-brand-0.2.0.tgz","fileCount":8,"unpackedSize":15078,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDL/NasDb6+sCGyRrxHu5q+D5nvPGwhb4SLcuBZLNV0cwIgKZ4QIxuW6YvQCCCF9VkZSMFx4x0tuJdgeRSbxtg8+rw="}]},"_npmUser":{"name":"kourge","email":"kourge@gmail.com"},"directories":{},"maintainers":[{"name":"kourge","email":"kourge@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-brand_0.2.0_1726260302486_0.12610413757415984"},"_hasShrinkwrap":false}},"time":{"created":"2017-10-02T22:30:08.968Z","modified":"2024-09-13T20:45:02.895Z","0.0.1":"2017-10-02T22:30:08.968Z","0.0.2":"2017-10-28T23:32:57.976Z","0.1.0":"2024-03-16T01:05:52.262Z","0.2.0":"2024-09-13T20:45:02.712Z"},"bugs":{"url":"https://github.com/kourge/ts-brand/issues"},"author":{"name":"Wil Lee","email":"kourge@gmail.com"},"license":"MIT","homepage":"https://github.com/kourge/ts-brand#readme","keywords":["typescript","opaque","branding","type"],"repository":{"type":"git","url":"git+https://github.com/kourge/ts-brand.git"},"description":"Reusable type branding in TypeScript","maintainers":[{"name":"kourge","email":"kourge@gmail.com"}],"readme":"# ts-brand\n\nWith `ts-brand`, you can achieve\n[nominal typing](https://basarat.gitbook.io/typescript/main-1/nominaltyping)\nby leveraging a technique that is called \"type branding\" in the TypeScript\ncommunity. Type branding works by intersecting a base type with a object type\nwith a non-existent property. It is closely related in principal and usage to\nFlow's\n[opaque type aliases](https://flow.org/en/docs/types/opaque-types/).\n\n## Installation\n\n```\nnpm install --save ts-brand\n```\n\n## Motivation and Example\n\nLet's say we have the following API:\n\n```ts\ndeclare function getPost(postId: number): Promise<Post>;\ndeclare function getUser(userId: number): Promise<User>;\n\ninterface User {\n  id: number;\n  name: string;\n}\n\ninterface Post {\n  id: number;\n  authorId: number;\n  title: string;\n  body: string;\n}\n```\n\nWe want to leverage this API to write a function that, given a post's ID, can\nretrieve the user who wrote said post:\n\n```ts\nfunction authorOfPost(postId: number): Promise<User> {\n  return getPost(postId).then(post => getUser(post.id));\n}\n```\n\nDo you spot the bug? We're passing `post.id` to `getUser`, but we should have\npassed `post.authorId`:\n\n```ts\nfunction authorOfPost(postId: number): Promise<User> {\n  return getPost(postId).then(post => getUser(post.authorId));\n}\n```\n\nNominal typing gives us a way to avoid conflating a user ID with a post ID,\neven though they are both numbers:\n\n```ts\nimport {Brand} from 'ts-brand';\n\ndeclare function getPost(postId: Post['id']): Promise<Post>;\ndeclare function getUser(userId: User['id']): Promise<User>;\n\ninterface User {\n  id: Brand<number, 'user'>;\n  name: string;\n}\n\ninterface Post {\n  id: Brand<number, 'post'>;\n  authorId: User['id'];\n  title: string;\n  body: string;\n}\n```\n\nWe have:\n\n* Defined the ID types in terms of branded types with different branding types\n* Substituted ad-hoc `number` types with a\n  [lookup type](https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#keyof-and-lookup-types), thus designating the interface as the centerpiece\n* Retained the same runtime semantics as the original code\n* Made our original buggy example fail to compile\n\nThere is one more risk left. If someone else were to define a different kind of\n`Post`, and also wrote `Brand<number, 'post'>`, it would still be possible to\nconflate the two accidentally. To solve this, we can take advantage of the fact\nthat TypeScript interfaces can be recursive:\n\n```ts\ninterface User {\n  id: Brand<number, User>;\n  name: string;\n}\n\ninterface Post {\n  id: Brand<number, Post>;\n  authorId: User['id'];\n  title: string;\n  body: string;\n}\n```\n\nBy defining the ID type in terms of the interface surrounding it, we have made\nit such that the only way an ID can be treated like a `Post['id']` is if its\nbranding type matches the structure of `Post` exactly.\n\n## API\n\nThis module exports four type members and two function members.\n\n### `type Brand<Base, Branding, [ReservedName]>`\n\nA `Brand` is a type that takes at minimum two type parameters. Given a base\ntype `Base` and some unique and arbitrary branding type `Branding`, it\nproduces a type based on but distinct from `Base`. The resulting branded type\nis not directly assignable from the base type, and not mutually assignable\nwith another branded type derived from the same base type.\n\nTake care that the branding type is unique. Two branded types that share the\nsame base type and branding type are considered the same type! There are two\nways to avoid this.\n\nThe first way is to supply a third type parameter, `ReservedName`, with a\nstring literal type that is not `__type__`, which is the default.\n\nThe second way is to define a branded type in terms of its surrounding\ninterface, thereby forming a recursive type. This is possible because there\nare no constraints on what the branding type must be. It does not have to be\na string literal type, even though it often is.\n\nThe third way is to define a branded type using an empty enum. In TypeScript,\nenums are nominally typed: two structurally identical enums are not considered\nthe same type. This prevents two enum-branded types from ever being conflated\nfor one another.\n\nExamples:\n\n```ts\ntype Path = Brand<string, 'path'>;\ntype UserId = Brand<number, 'user'>;\ntype DifferentUserId = Brand<number, 'user', '__kind__'>;\ninterface Post {\n  id: Brand<number, Post>;\n}\nenum TimeTag {}\ntype Time = Brand<number, TimeTag>;\n```\n\n### `type AnyBrand`\n\nAn `AnyBrand` is a branded type based on any base type branded with any\nbranding type. By itself it is not useful, but it can act as type constraint\nwhen manipulating branded types in general.\n\n### `type BaseOf<B extends AnyBrand>`\n\n`BaseOf` is a type that takes any branded type `B` and yields its base type.\n\n### `type Brander<B extends AnyBrand>`\n\nA `Brander` is a function that takes a value of some base type and casts that\nvalue to a branded type derived from said base type. It can be thought of as\nthe type of a \"constructor\", in the functional programming sense of the word.\n\nExample:\n\n```ts\ntype UserId = Brand<number, 'user'>;\n// A Brander<UserId> would take a number and return a UserId\n```\n\n### `function identity<B extends AnyBrand>(underlying: BaseOf<B>): B`\n\nA generic function that, when given some branded type, can take a value with\nthe base type of the branded type, and cast that value to the branded type.\nIt fulfills the contract of a `Brander`.\n\nAt runtime, this function simply returns the value as-is.\n\nExample:\n\n```ts\ntype UserId = Brand<number, 'user'>;\nconst UserId: Brander<UserId> = identity;\n```\n\n### `function make<B extends AnyBrand>(): Brander<B>`\n\nProduces a `Brander<B>`, given a brand type `B`. By default this returns\n`identity` but relies on type inference to give the return type the correct\ntype.\n\nExample:\n\n```ts\ntype UserId = Brand<number, 'user'>;\nconst UserId = make<UserId>();\nconst myUserId = UserId(42);\n```\n\nOptionally, you may provide a validation function to assert that the value is\nthe expected data shape. This may be done by passing a function to `make`:\n\n```ts\ntype UserId = Brand<number, 'user'>;\nconst UserId = make<UserId>((value) => {\n  if (value <= 0) {\n    throw new Error(`Non-positive value: ${value}`);\n  }\n});\nUserId(42); // Ok\nUserId(-1); // Error: Non-positive value: -1\n```\n\n## Complete Example\n\nWe can form a cohesive, intuitive API definition by leveraging several features\nat once, such as namespace merging, type inference, and lookup types:\n\n```ts\nimport {Brand, make} from 'ts-brand';\n\nexport interface User {\n  id: Brand<number, User>;\n  name: string;\n}\n\nexport namespace User {\n  export type Id = User['id'];\n  export const Id = make<Id>();\n}\n\nexport interface Post {\n  id: Brand<number, Post>;\n  authorId: User.Id;\n  title: string;\n  body: string;\n}\n\nexport namespace Post {\n  export type Id = Post['id'];\n  export const Id = make<Id>();\n}\n\ndeclare function getPost(id: Post.Id): Promise<Post>;\ndeclare function getUser(id: User.Id): Promise<User>;\n```\n","readmeFilename":"README.md"}